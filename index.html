<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tetris Quest RPG</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=DotGothic16&display=swap');

        :root {
            --bg-color: #1a1a2e;
            --grid-color: #16213e;
            --ui-bg: #0f3460;
            --text-color: #e94560;
        }

        body {
            font-family: 'DotGothic16', sans-serif;
            background-color: var(--bg-color);
            color: white;
            touch-action: none; /* Prevent pull-to-refresh on mobile */
            overflow: hidden; /* **„Çπ„ÇØ„É≠„Éº„É´„ÇíÂÆåÂÖ®„Å´Á¶ÅÊ≠¢** */
            user-select: none;
            -webkit-user-select: none;
            padding: 0;
            margin: 0;
            height: 100%; /* 100vh„Åã„ÇâÂ§âÊõ¥ */
        }

        /* Custom Scrollbar for Log */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #0f3460; 
        }
        ::-webkit-scrollbar-thumb {
            background: #e94560; 
            border-radius: 4px;
        }

        .game-container {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 10px;
            max-width: 1000px;
            margin: 0 auto;
            height: 100vh; /* „Éì„É•„Éº„Éù„Éº„Éà„ÅÆÈ´ò„Åï„Çí‰ΩøÁî® */
            padding: 10px;
            position: relative;
        }

        /* MOBILE LAYOUT ADJUSTMENTS (Single Column Stack) */
        @media (max-width: 768px) {
            .game-container {
                /* New fixed layout for mobile: Tetris > Skills (fixed) */
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto; 
                height: 100vh; /* Use full viewport height */
                padding: 5px; /* Reduced overall padding */
                padding-bottom: 55px; /* Space for skill buttons at the bottom */
                gap: 5px;
            }
            /* Explicitly define order for mobile */
            .tetris-panel { order: 1; padding: 0; } 
            #battle-hud { display: none; } /* HIDDEN in the flow, will be ABOSLUTELY positioned */
            .log-panel { display: none; } 
            .mobile-controls-fixed { order: 2; display: flex; }

            /* Tetris Board sizing: maximize width while maintaining aspect ratio */
            .tetris-panel {
                 /* Ensure panel takes up max height possible to push controls to the bottom */
                height: calc(100vh - 55px - 10px); /* viewport height - controls height - padding */
                display: flex;
                align-items: center; /* Center board vertically within the panel */
                justify-content: center;
            }
            #tetris-board { 
                width: 95vw; 
                max-width: 300px; 
                height: 0; 
                padding-bottom: 200%; 
                position: relative;
                margin: auto; /* Center board horizontally */
                display: block; /* Use block for absolute cell positioning */
            }
            
            .cell {
                position: absolute;
                width: 10%; 
                height: 5%; 
                border: 1px solid rgba(255,255,255,0.1);
                box-sizing: border-box;
            }
            
            .desktop-only { display: none; }

            /* Overlay HUD Styling */
            #mobile-hud-overlay {
                display: grid; 
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                z-index: 10;
                grid-template-columns: 1fr 1fr; 
                gap: 10px;
                padding: 8px 10px;
                background: rgba(15, 52, 96, 0.8); /* Semi-transparent background */
                border-radius: 8px 8px 0 0;
            }
            #mobile-hud-overlay .bar-container { height: 6px; margin-bottom: 4px; }
            #mobile-hud-overlay .player-name, #mobile-hud-overlay .enemy-name {
                 font-size: 0.8rem;
                 font-weight: bold;
             }
             .player-info-hud { border-right: 1px dashed rgba(255,255,255,0.3); padding-right: 10px; }
             .enemy-info-hud { padding-left: 10px; text-align: right; }
        }

        /* General Panel Styling */
        .panel {
            background: var(--ui-bg);
            border: 2px solid #4a5568;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        .tetris-panel {
             display: flex;
             flex-direction: column;
             align-items: center;
             justify-content: flex-start; 
             order: 1; 
        }
        @media (min-width: 769px) {
            .tetris-panel { order: 2; height: 100%; justify-content: center; } 
            .game-container { padding: 10px; }
            #tetris-board { 
                width: 250px; 
                height: 500px; 
                padding-bottom: 0; 
                display: grid; 
            } 
             #tetris-board > .cell {
                position: static;
                width: 100%;
                height: 100%;
            }
        }


        /* Tetris Grid */
        #tetris-board {
            border: 4px solid #e94560;
            background-color: rgba(0, 0, 0, 0.8);
            grid-template-rows: repeat(20, 1fr);
            grid-template-columns: repeat(10, 1fr);
            touch-action: none;
        }
        
        /* Block Colors (No changes to block classes) */
        .block-i { background: cyan; box-shadow: inset 0 0 8px rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.4); }
        .block-j { background: blue; box-shadow: inset 0 0 8px rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.4); }
        .block-l { background: orange; box-shadow: inset 0 0 8px rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.4); }
        .block-o { background: yellow; box-shadow: inset 0 0 8px rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.4); }
        .block-s { background: lime; box-shadow: inset 0 0 8px rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.4); }
        .block-t { background: purple; box-shadow: inset 0 0 8px rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.4); }
        .block-z { background: red; box-shadow: inset 0 0 8px rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.4); }
        .block-ghost { background: rgba(255, 255, 255, 0.1); border: 1px dashed rgba(255,255,255,0.3); }

        /* Animations (No changes) */
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }

        .shake-anim {
            animation: shake 0.5s;
            animation-iteration-count: 1;
        }

        @keyframes damage-float {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-50px); }
        }

        .damage-text {
            position: absolute;
            color: #ff0000;
            font-weight: bold;
            font-size: 24px;
            pointer-events: none;
            animation: damage-float 1s ease-out forwards;
            text-shadow: 2px 2px 0px #000;
        }
        
        .heal-text {
            position: absolute;
            color: #00ff00;
            font-weight: bold;
            font-size: 24px;
            pointer-events: none;
            animation: damage-float 1s ease-out forwards;
            text-shadow: 2px 2px 0px #000;
        }

        /* RPG Bars */
        .bar-container {
            background: #333;
            height: 16px; /* Desktop default */
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 5px;
            position: relative;
        }
        .bar-fill {
            height: 100%;
            transition: width 0.3s ease;
        }
        .hp-fill { background: #e53e3e; }
        .mp-fill { background: #3182ce; }
        .exp-fill { background: #d69e2e; }
        .enemy-timer-fill { background: #805ad5; }

        /* Mobile Controls - Fixed at Bottom */
        .mobile-controls-fixed {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(0, 0, 0, 0.7);
            border-top: 2px solid #e94560;
            justify-content: center;
            gap: 20px;
            padding: 5px 10px; 
            height: 50px; 
            z-index: 90;
        }
        @media (max-width: 768px) {
            .mobile-controls-fixed { display: flex; }
            
            /* Combined HUD Styling */
            #battle-hud { display: none; } /* HIDDEN in flow */
        }
        .ctrl-btn {
            background: rgba(255,255,255,0.15);
            border: 2px solid rgba(255,255,255,0.4);
            border-radius: 12px;
            color: white;
            font-size: 14px; 
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            padding: 2px 10px; 
            min-width: 80px;
            box-shadow: 0 4px 0 rgba(0,0,0,0.5);
        }
        .ctrl-btn:active { 
            background: rgba(255,255,255,0.3); 
            transform: translateY(4px);
            box-shadow: 0 0 0 rgba(0,0,0,0.5);
        }
        
        /* Enemy Sprite Placeholder */
        .enemy-sprite {
            font-size: 80px;
            text-align: center;
            filter: drop-shadow(0 0 10px rgba(255,0,0,0.5));
            transition: transform 0.1s;
        }

        /* Modal (No changes) */
        .modal {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            flex-direction: column;
            padding: 20px;
        }
        .modal.hidden { display: none; }

        /* Sound Control (No changes) */
        .sound-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100; /* Increased Z-index to be above HUD overlay */
            background: rgba(0,0,0,0.5);
            border: 1px solid #4a5568;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 20px;
        }
        .sound-toggle:hover { background: rgba(255,255,255,0.1); }

        /* Touch Hints (removed for ultra-minimalist mobile) */
    </style>
</head>
<body>

    <!-- Sound Toggle Button -->
    <button id="sound-btn" class="sound-toggle" onclick="toggleSound()">üîá</button>
    
    <!-- Loading Screen (Now hidden, as we don't need Firebase init time) -->
    <div id="loading-screen" class="modal hidden">
        <h1 class="text-4xl text-pink-500 mb-4">Loading...</h1>
        <p>Initializing Game Data.</p>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="modal hidden">
        <h1 class="text-6xl text-pink-500 mb-4 text-shadow-lg glow">TETRIS QUEST</h1>
        <p class="mb-8 text-xl text-gray-300">„É©„Ç§„É≥„ÇíÊ∂à„Åó„Å¶„É¢„É≥„Çπ„Çø„Éº„ÇíÂÄí„ÅõÔºÅ</p>
        
        <div class="w-full max-w-sm mb-6">
            <label for="player-name-input" class="block text-lg font-bold mb-2">„Éó„É¨„Ç§„É§„ÉºÂêç:</label>
            <input type="text" id="player-name-input" maxlength="12" placeholder="ÂêçÂâç„ÇíÂÖ•Âäõ (12ÊñáÂ≠ó‰ª•ÂÜÖ)" class="w-full p-3 rounded bg-gray-700 text-white border-2 border-pink-500 focus:outline-none focus:border-pink-300">
        </div>
        
        <div class="flex flex-col gap-4 w-full max-w-xs">
            <button onclick="startGame(false)" class="px-8 py-4 bg-pink-600 hover:bg-pink-500 rounded text-2xl font-bold shadow-lg transform transition hover:scale-105">
                Êñ∞„Åó„ÅèÂÜíÈô∫„ÇíÂßã„ÇÅ„Çã
            </button>
            <button onclick="startGame(true)" id="continue-btn" class="px-8 py-4 bg-yellow-600 hover:bg-yellow-500 rounded text-2xl font-bold shadow-lg transform transition hover:scale-105 hidden">
                „Çª„Éº„Éñ„Åã„ÇâÁ∂ö„Åë„Çã
            </button>
            <button onclick="showRanking()" class="px-8 py-3 bg-gray-600 hover:bg-gray-500 rounded text-xl font-bold shadow-lg mt-4">
                üèÜ „É©„É≥„Ç≠„É≥„Ç∞„ÇíË¶ã„Çã
            </button>
        </div>

        <div class="mt-8 text-sm text-gray-400 text-center">
            <p class="desktop-only">Êìç‰Ωú: Áü¢Âç∞„Ç≠„ÉºÁßªÂãï/ÂõûËª¢, Space: „Éâ„É≠„ÉÉ„Éó, Z/X: „Çπ„Ç≠„É´</p>
            <p class="md:hidden">Êìç‰Ωú: „Çπ„ÉØ„Ç§„Éó„ÅßÁßªÂãï„ÉªËêΩ‰∏ã, „Çø„ÉÉ„Éó„ÅßÂõûËª¢</p>
        </div>
    </div>

    <!-- Ranking Screen -->
    <div id="ranking-screen" class="modal hidden">
        <h1 class="text-5xl text-yellow-400 mb-6">üèÜ „É©„É≥„Ç≠„É≥„Ç∞</h1>
        <div class="bg-gray-800 p-4 rounded max-w-md w-full max-h-96 overflow-y-auto">
            <table class="w-full text-left">
                <thead>
                    <tr class="text-pink-500 border-b border-gray-600">
                        <th class="p-2">È†Ü‰Ωç</th>
                        <th class="p-2">„Éó„É¨„Ç§„É§„Éº</th>
                        <th class="p-2 text-right">Ë®é‰ºêÊï∞ (Score)</th>
                    </tr>
                </thead>
                <tbody id="ranking-list">
                    <!-- Ranking data inserted here -->
                </tbody>
            </table>
        </div>
        <button onclick="hideRanking()" class="px-6 py-3 bg-pink-600 hover:bg-pink-500 rounded text-xl font-bold mt-8">
            Êàª„Çã
        </button>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="modal hidden">
        <h1 class="text-5xl text-red-500 mb-4">GAME OVER</h1>
        <p id="final-score" class="text-2xl mb-4">Level: 1</p>
        <p id="final-enemies" class="text-xl mb-6">Enemies Defeated: 0</p>
        <p id="ranking-message" class="text-lg text-yellow-300 mb-8"></p>
        <button onclick="location.reload()" class="px-6 py-3 bg-gray-600 hover:bg-gray-500 rounded text-xl font-bold">
            „Çø„Ç§„Éà„É´„Å´Êàª„Çã
        </button>
    </div>

    <div class="game-container" id="game-container-div">
        
        <!-- Center Panel: Tetris Board (Order 1 on Mobile) -->
        <div class="panel tetris-panel order-2 relative">
            <!-- Effects Layer -->
            <div id="effects-layer" class="absolute inset-0 pointer-events-none flex justify-center items-center z-10"></div>
            
            <div id="tetris-board">
                <!-- Cells generated by JS -->
            </div>
            
            <!-- MOBILE HUD OVERLAY (New Absolute Element) -->
            <div id="mobile-hud-overlay" class="md:hidden">
                <!-- Player Summary (HP/MP) -->
                <div class="player-info-hud">
                    <!-- ADDED ID HERE -->
                    <div class="player-name text-yellow-400"><span id="player-name-mobile-hud">HERO</span> (Lv.<span id="player-level-mobile">1</span>)</div>
                    <div class="bar-container mb-1"><div id="hp-bar-hud" class="bar-fill hp-fill" style="width: 100%"></div></div>
                    <div class="bar-container"><div id="mp-bar-hud" class="bar-fill mp-fill" style="width: 100%"></div></div>
                </div>
                
                <!-- Enemy Summary (HP/Timer) -->
                <div class="enemy-info-hud">
                    <div class="enemy-name text-red-400" id="enemy-name-hud">üíß Slime</div>
                    <div class="bar-container mb-1"><div id="enemy-hp-bar-hud" class="bar-fill bg-red-600" style="width: 100%"></div></div>
                    <div class="bar-container"><div id="enemy-timer-bar-hud" class="bar-fill enemy-timer-fill" style="width: 0%"></div></div>
                </div>
            </div>
            <!-- END MOBILE HUD OVERLAY -->
        </div>

        <!-- HIDDEN Mobile HUD (Old element, kept for desktop layout consistency but hidden) -->
        <div class="panel order-1 md:hidden" id="battle-hud" style="display: none;"></div>
        
        <!-- Mobile Log (Order 3 on Mobile) - HIDDEN -->
        <div class="panel log-panel md:hidden order-3" style="display: none !important;">
             <h3 class="text-sm font-bold mb-1 border-b border-gray-600 pb-1">BATTLE LOG</h3>
             <div class="bg-black bg-opacity-50 rounded p-2 overflow-y-auto font-mono text-xs" id="game-log-mobile" style="height: 60px;">
                <div class="text-gray-400">Welcome to Tetris Quest!</div>
            </div>
        </div>


        <!-- Left Panel: Player Stats & Skills (Desktop Only) -->
        <div class="panel flex flex-col justify-between desktop-only order-1">
            <div>
                <!-- ADDED ID HERE -->
                <h2 class="text-xl font-bold mb-2 text-yellow-400"><span id="player-name-desktop">HERO</span> („ÅÇ„Å™„Åü)</h2> 
                <div class="mb-1 flex justify-between text-sm"><span>LV. <span id="player-level">1</span></span> <span>ATK: <span id="player-atk">10</span></span></div>
                
                <div class="text-xs mb-1">HP <span id="hp-text">100/100</span></div>
                <div class="bar-container"><div id="hp-bar" class="bar-fill hp-fill" style="width: 100%"></div></div>
                
                <div class="text-xs mb-1">MP <span id="mp-text">50/50</span></div>
                <div class="bar-container"><div id="mp-bar" class="bar-fill mp-fill" style="width: 100%"></div></div>

                <div class="text-xs mb-1">EXP</div>
                <div class="bar-container"><div id="exp-bar" class="bar-fill exp-fill" style="width: 0%"></div></div>
            </div>

            <div class="mt-4">
                <h3 class="text-lg font-bold mb-2 border-b border-gray-600 pb-1">SKILLS</h3>
                <button onclick="castSkill('heal')" id="btn-heal" class="w-full mb-2 bg-green-800 hover:bg-green-700 p-2 rounded text-sm flex justify-between items-center disabled:opacity-50 disabled:cursor-not-allowed">
                    <span>üíñ ÂõûÂæ© (Heal)</span> <span class="text-blue-300">20MP</span>
                </button>
                <button onclick="castSkill('bomb')" id="btn-bomb" class="w-full bg-red-900 hover:bg-red-800 p-2 rounded text-sm flex justify-between items-center disabled:opacity-50 disabled:cursor-not-allowed">
                    <span>üí£ ÁàÜÁ†¥ (Bomb)</span> <span class="text-blue-300">30MP</span>
                </button>
                <p class="text-xs text-gray-400 mt-2 text-center">Key: Z (Heal) / X (Bomb)</p>
            </div>

            <div class="mt-auto">
                <h3 class="font-bold mb-1">NEXT</h3>
                <div id="next-piece-display" class="w-20 h-20 border border-gray-600 mx-auto bg-black grid grid-cols-4 grid-rows-4"></div>
            </div>
        </div>

        <!-- Right Panel: Enemy & Log (Desktop Only) -->
        <div class="panel flex flex-col desktop-only order-3">
            <div class="text-center mb-4 relative">
                <h2 class="text-xl font-bold mb-1 text-red-400" id="enemy-name">Slime</h2>
                <div id="enemy-visual" class="enemy-sprite my-4">üíß</div>
                
                <div class="bar-container h-4 mb-1 bg-gray-700 border border-gray-500">
                    <div id="enemy-hp-bar" class="bar-fill bg-red-600" style="width: 100%"></div>
                </div>
                <div class="text-xs text-right mb-2">HP: <span id="enemy-hp-text">50</span></div>

                <div class="text-xs text-left mb-1 text-purple-300">ATTACK TIMER</div>
                <div class="bar-container h-2">
                    <div id="enemy-timer-bar" class="bar-fill enemy-timer-fill" style="width: 0%"></div>
                </div>
            </div>

            <div class="flex-grow bg-black bg-opacity-50 rounded p-2 overflow-y-auto font-mono text-xs" id="game-log" style="height: 150px;">
                <div class="text-gray-400">Welcome to Tetris Quest!</div>
            </div>
        </div>
        
    </div>

    <!-- Mobile Controls (Skills Only) - Fixed at Bottom (Order 4 on Mobile) -->
    <div class="mobile-controls-fixed md:hidden col-span-full">
        <button class="ctrl-btn" onclick="castSkill('heal')">üíñ HEAL</button>
        <button class="ctrl-btn" onclick="castSkill('bomb')">üí£ BOMB</button>
    </div>

<script>
    // --- LocalStorage Keys ---
    const SAVE_KEY = 'tetrisQuestSave';
    const RANKING_KEY = 'tetrisQuestRanking';

    // --- Audio System (Kept the same) ---
    const AudioSys = {
        ctx: null,
        isMuted: true,
        bgmOscillators: [],
        bgmInterval: null,
        bgmNoteIndex: 0,
        
        init: function() {
            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
        },

        toggle: function() {
            const btn = document.getElementById('sound-btn');
            if (this.isMuted) {
                this.isMuted = false;
                btn.innerText = "üîä";
                if (!this.ctx) this.init();
                if (this.ctx.state === 'suspended') this.ctx.resume();
                if (gameRunning) this.playBGM('battle');
            } else {
                this.isMuted = true;
                btn.innerText = "üîá";
                this.stopBGM();
            }
        },

        playTone: function(freq, type, duration, vol = 0.1, slideTo = null) {
            if (this.isMuted || !this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            
            osc.type = type;
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            if (slideTo) {
                osc.frequency.exponentialRampToValueAtTime(slideTo, this.ctx.currentTime + duration);
            }

            gain.gain.setValueAtTime(vol, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + duration);
        },

        playNoise: function(duration, vol = 0.1) {
            if (this.isMuted || !this.ctx) return;
            const bufferSize = this.ctx.sampleRate * duration;
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }

            const noise = this.ctx.createBufferSource();
            noise.buffer = buffer;
            const gain = this.ctx.createGain();
            
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 1000;

            gain.gain.setValueAtTime(vol, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

            noise.connect(filter);
            filter.connect(gain);
            gain.connect(this.ctx.destination);
            noise.start();
        },

        play: function(name) {
            if(this.isMuted) return;
            switch(name) {
                case 'move': 
                    this.playTone(150, 'triangle', 0.05, 0.05); 
                    break;
                case 'rotate': 
                    this.playTone(400, 'square', 0.1, 0.05, 600); 
                    break;
                case 'drop': 
                    this.playTone(100, 'sawtooth', 0.15, 0.1, 50); 
                    break;
                case 'clear': 
                    setTimeout(() => this.playTone(523.25, 'square', 0.1, 0.1), 0);
                    setTimeout(() => this.playTone(659.25, 'square', 0.1, 0.1), 50);
                    setTimeout(() => this.playTone(783.99, 'square', 0.2, 0.1), 100);
                    break;
                case 'tetris': 
                    [523.25, 659.25, 783.99, 1046.50].forEach((f, i) => {
                        setTimeout(() => this.playTone(f, 'square', 0.3, 0.15), i * 60);
                    });
                    break;
                case 'damage': 
                    this.playNoise(0.3, 0.2); 
                    break;
                case 'attack':
                    this.playTone(200, 'sawtooth', 0.1, 0.1, 50);
                    setTimeout(() => this.playNoise(0.1, 0.1), 50);
                    break;
                case 'heal': 
                    this.playTone(440, 'sine', 0.4, 0.1, 880); 
                    break;
                case 'levelup':
                    [440, 554, 659, 880, 1108, 1318].forEach((f, i) => {
                        setTimeout(() => this.playTone(f, 'square', 0.2, 0.1), i * 80);
                    });
                    break;
                case 'gameover':
                    this.playTone(300, 'sawtooth', 1.0, 0.2, 50);
                    break;
            }
        },

        playBGM: function(type) {
            this.stopBGM();
            if (this.isMuted || !this.ctx) return;

            const tempo = 150;
            let melody = [];
            
            if (type === 'battle') {
                const notes = [
                    659, 493, 523, 587, 523, 493, 440, 440, 523, 659, 587, 523, 493, 523, 587, 659, 523, 440, 440, 0
                ];
                melody = notes;
            }

            this.bgmNoteIndex = 0;
            
            const playNextNote = () => {
                if (!gameRunning || this.isMuted) return;
                
                const freq = melody[this.bgmNoteIndex];
                if (freq > 0) {
                    this.playTone(freq / 2, 'square', 0.1, 0.03);
                    this.playTone(freq, 'triangle', 0.1, 0.03);
                }

                this.bgmNoteIndex = (this.bgmNoteIndex + 1) % melody.length;
            };

            this.bgmInterval = setInterval(playNextNote, 200);
        },

        stopBGM: function() {
            if (this.bgmInterval) {
                clearInterval(this.bgmInterval);
                this.bgmInterval = null;
            }
        }
    };

    function toggleSound() {
        // AudioSys.toggle() „ÅÆÂëº„Å≥Âá∫„Åó„ÅØÂïèÈ°å„Å™„Åó„ÄÇtoggle()„É°„ÇΩ„ÉÉ„ÉâÂÜÖ„ÅÆthisÂèÇÁÖß„Çí‰øÆÊ≠£„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çã„Åü„ÇÅ„ÄÅ
        // toggleSound()„ÅØ„Åù„ÅÆ„Åæ„Åæ„Å´„Åó„Å¶„ÄÅAudioSys.toggle()„Çí‰øÆÊ≠£„Åó„Åæ„Åô„ÄÇ
        AudioSys.toggle.call(AudioSys);
    }

    // --- Game Data Structure ---
    const DEFAULT_PLAYER = {
        playerName: 'HERO',
        maxHp: 100, hp: 100, maxMp: 50, mp: 50, level: 1, exp: 0, expToNext: 100, atk: 10
    };

    const PIECES = [
        [],
        { shape: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], class: 'block-i' },
        { shape: [[1,0,0],[1,1,1],[0,0,0]], class: 'block-j' },
        { shape: [[0,0,1],[1,1,1],[0,0,0]], class: 'block-l' },
        { shape: [[1,1],[1,1]], class: 'block-o' },
        { shape: [[0,1,1],[1,1,0],[0,0,0]], class: 'block-s' },
        { shape: [[0,1,0],[1,1,1],[0,0,0]], class: 'block-t' },
        { shape: [[1,1,0],[0,1,1],[0,0,0]], class: 'block-z' }
    ];

    const ENEMIES_DATA = [
        { name: "Slime", icon: "üíß", hp: 50, atk: 5, exp: 30 },
        { name: "Bat", icon: "ü¶á", hp: 80, atk: 8, exp: 40 },
        { name: "Skeleton", icon: "üíÄ", hp: 120, atk: 12, exp: 60 },
        { name: "Orc", icon: "üëπ", hp: 200, atk: 15, exp: 100 },
        { name: "Dragon", icon: "üêâ", hp: 500, atk: 25, exp: 300 },
        { name: "Demon King", icon: "üëø", hp: 1000, atk: 40, exp: 1000 }
    ];

    // --- Game State Variables ---
    const ROWS = 20;
    const COLS = 10;
    let board = [];
    let gameRunning = false;
    let lastTime = 0;
    let dropCounter = 0;
    let dropInterval = 1000; 
    let currentPiece = null;
    let nextPieceType = null;
    
    let player = JSON.parse(JSON.stringify(DEFAULT_PLAYER)); // Deep copy
    let enemy = null;
    let enemyAttackTimer = 0;
    const ENEMY_ATTACK_INTERVAL = 5000;
    let enemyIndex = 0;

    let hasSaveData = false;


    // --- DOM Elements ---
    const boardEl = document.getElementById('tetris-board');
    const logElDesktop = document.getElementById('game-log');


    // --- LocalStorage Save/Load/Ranking ---

    function checkSaveData() {
        const savedData = localStorage.getItem(SAVE_KEY);
        hasSaveData = !!savedData;
        if (hasSaveData) {
            document.getElementById('continue-btn').classList.remove('hidden');
            try {
                const data = JSON.parse(savedData);
                document.getElementById('player-name-input').value = data.player.playerName || '';
            } catch (e) {
                console.error("Error parsing save data:", e);
                hasSaveData = false;
            }
        }
    }

    function saveGame() {
        if (!currentPiece) return;
        
        try {
            const saveData = {
                timestamp: Date.now(),
                player: player,
                board: board,
                currentPiece: {
                    matrix: currentPiece.matrix,
                    class: currentPiece.class,
                    x: currentPiece.x,
                    y: currentPiece.y
                },
                nextPieceType: nextPieceType,
                enemy: enemy,
                enemyAttackTimer: enemyAttackTimer,
                enemyIndex: enemyIndex,
                dropInterval: dropInterval
            };
            
            localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
            console.log("Game Saved to LocalStorage.");
            hasSaveData = true; // Update flag
        } catch (e) {
            console.error("Error saving game:", e);
        }
    }

    function loadGame() {
        if (!hasSaveData) return false;
        try {
            const savedData = localStorage.getItem(SAVE_KEY);
            if (savedData) {
                const data = JSON.parse(savedData);
                
                // Load Player
                Object.assign(player, data.player);
                
                // Load Board and Pieces
                board = data.board;
                currentPiece = data.currentPiece;
                nextPieceType = data.nextPieceType;

                // Load Enemy
                enemy = data.enemy;
                enemyAttackTimer = data.enemyAttackTimer;
                enemyIndex = data.enemyIndex;
                dropInterval = data.dropInterval;
                
                log("„Çª„Éº„Éñ„Éá„Éº„Çø„Çí„É≠„Éº„Éâ„Åó„Åæ„Åó„ÅüÔºÅ", "text-blue-300");
                return true;
            }
        } catch (e) {
            console.error("Error loading game:", e);
        }
        return false;
    }
    
    function deleteSaveData() {
        localStorage.removeItem(SAVE_KEY);
        hasSaveData = false;
        document.getElementById('continue-btn').classList.add('hidden');
        console.log("Save Data Deleted from LocalStorage.");
    }

    function submitScore(playerName, enemiesDefeated, finalLevel) {
        let rankings = JSON.parse(localStorage.getItem(RANKING_KEY) || '[]');
        
        const newScore = {
            playerName: playerName,
            score: enemiesDefeated,
            level: finalLevel,
            timestamp: Date.now()
        };
        
        rankings.push(newScore);
        
        // Sort by score (desc), then level (desc), then timestamp (desc)
        rankings.sort((a, b) => {
            if (b.score !== a.score) return b.score - a.score;
            if (b.level !== a.level) return b.level - a.level;
            return b.timestamp - a.timestamp;
        });
        
        // Keep only top 10
        rankings = rankings.slice(0, 10);
        
        localStorage.setItem(RANKING_KEY, JSON.stringify(rankings));
    }

    function getRanking() {
        const rankings = JSON.parse(localStorage.getItem(RANKING_KEY) || '[]');
        return rankings;
    }
    
    function showRanking() {
        const rankings = getRanking();
        const listEl = document.getElementById('ranking-list');
        listEl.innerHTML = '';
        
        if (rankings.length === 0) {
            listEl.innerHTML = '<tr><td colspan="3" class="p-2 text-gray-400 text-center">„Åæ„Å†„Çπ„Ç≥„Ç¢„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</td></tr>';
        } else {
            rankings.forEach((rank, index) => {
                const row = document.createElement('tr');
                row.className = index % 2 === 0 ? 'bg-gray-700' : 'bg-gray-800';
                row.innerHTML = `
                    <td class="p-2">${index + 1}</td>
                    <td class="p-2">${rank.playerName || 'ÂêçÁÑ°„Åó'} (Lv.${rank.level})</td>
                    <td class="p-2 text-right">${rank.score} Âåπ</td>
                `;
                listEl.appendChild(row);
            });
        }
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('ranking-screen').classList.remove('hidden');
    }

    function hideRanking() {
        document.getElementById('ranking-screen').classList.add('hidden');
        document.getElementById('start-screen').classList.remove('hidden');
    }


    // --- Game Core Functions ---

    function initBoard() {
        board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        boardEl.innerHTML = '';
        const isMobile = window.innerWidth <= 768;

        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                cell.id = `cell-${r}-${c}`;
                
                if (isMobile) {
                    cell.style.top = `${r * 5}%`;
                    cell.style.left = `${c * 10}%`;
                } else {
                    cell.style.top = ''; 
                    cell.style.left = '';
                }

                boardEl.appendChild(cell);
            }
        }
    }

    function startGame(isContinue) {
        
        const playerNameInput = document.getElementById('player-name-input');
        const name = playerNameInput.value.trim() || 'ÂêçÁÑ°„Åó';
        player.playerName = name;
        
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('game-over-screen').classList.add('hidden');
        
        let loaded = false;
        if (isContinue) {
            loaded = loadGame();
        }
        
        if (!loaded || !isContinue) {
            // Reset RPG stats for new game
            Object.assign(player, JSON.parse(JSON.stringify(DEFAULT_PLAYER))); // Reset to default
            player.playerName = name;
            enemyIndex = 0; 
            
            // Reset Tetris state
            initBoard();
            dropInterval = 1000;
            
            spawnEnemy();
            spawnPiece();
            log("Êñ∞„Åó„ÅèÂÜíÈô∫„ÅåÂßã„Åæ„Å£„ÅüÔºÅ");
        }

        // Audio Init/Start
        if (!AudioSys.ctx && !AudioSys.isMuted) AudioSys.init();
        if (AudioSys.ctx && AudioSys.ctx.state === 'suspended') AudioSys.ctx.resume();
        AudioSys.playBGM('battle');
        
        gameRunning = true;
        updatePlayerUI(); // „Éó„É¨„Ç§„É§„ÉºÂêç„Çí„Åì„Åì„ÅßÊõ¥Êñ∞
        updateEnemyUI();
        
        // Initialize Touch Controls 
        initTouchControls();
        
        // Start main loop
        requestAnimationFrame(update);
    }
    
    // Add event listener to save game state when the window closes or refreshes (best effort)
    window.addEventListener('beforeunload', () => {
        if (gameRunning) {
            saveGame();
        }
    });

    function gameOver() {
        if (!gameRunning) return;
        gameRunning = false;
        AudioSys.stopBGM();
        AudioSys.play('gameover');
        
        document.getElementById('final-score').innerText = `„É¨„Éô„É´: ${player.level}`;
        document.getElementById('final-enemies').innerText = `Ë®é‰ºêÊï∞: ${enemyIndex} Âåπ`;

        // 1. „Çπ„Ç≥„Ç¢„Çí„É©„É≥„Ç≠„É≥„Ç∞„Å´Ë®òÈå≤
        submitScore(player.playerName, enemyIndex, player.level);
        
        // 2. „Çª„Éº„Éñ„Éá„Éº„Çø„ÇíÂâäÈô§Ôºà„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº„ÅÆ„Åü„ÇÅÔºâ
        deleteSaveData();
        
        document.getElementById('ranking-message').innerText = "„ÅÇ„Å™„Åü„ÅÆ„Çπ„Ç≥„Ç¢„Çí„É©„É≥„Ç≠„É≥„Ç∞„Å´Ë®òÈå≤„Åó„Åæ„Åó„ÅüÔºÅ";
        
        document.getElementById('game-over-screen').classList.remove('hidden');
    }

    // --- EXISTING GAME LOGIC ---

    // Touch control variables
    let touchStartX = 0;
    let touchStartY = 0;
    let lastTouchX = 0;
    let lastTouchY = 0;
    let isTouchMoving = false;
    let touchStartTime = 0;
    const TAP_MAX_TIME = 250;
    const TAP_MAX_DIST = 10;
    
    
    function initTouchControls() {
        const touchArea = document.getElementById('tetris-board');
        
        touchArea.addEventListener('touchstart', (e) => {
            if (!gameRunning) return;
            if(e.target.tagName === 'BUTTON') return;
            
            e.preventDefault();
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            lastTouchX = touch.clientX;
            lastTouchY = touch.clientY;
            touchStartTime = Date.now();
            isTouchMoving = false;
        }, {passive: false});

        touchArea.addEventListener('touchmove', (e) => {
            if (!gameRunning) return;
            if(e.target.tagName === 'BUTTON') return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const dx = touch.clientX - lastTouchX;
            const dy = touch.clientY - lastTouchY;
            
            if (Math.abs(dx) > 15) {
                const steps = Math.floor(Math.abs(dx) / 15); 
                if (steps > 0) {
                    const dir = dx > 0 ? 1 : -1;
                    for(let i=0; i<steps; i++) {
                        if(movePiece(dir, 0)) {}
                    }
                    lastTouchX = touch.clientX;
                    isTouchMoving = true;
                }
            }

            if (dy > 25) {
                movePiece(0, 1);
                lastTouchY = touch.clientY;
                isTouchMoving = true;
            }
        }, {passive: false});

        touchArea.addEventListener('touchend', (e) => {
            if (!gameRunning) return;
            if(e.target.tagName === 'BUTTON') return;
            
            const duration = Date.now() - touchStartTime;
            const dist = Math.hypot(e.changedTouches[0].clientX - touchStartX, e.changedTouches[0].clientY - touchStartY);

            if (!isTouchMoving && duration < TAP_MAX_TIME && dist < TAP_MAX_DIST) {
                rotate();
            }
        });
    }

    function spawnEnemy() {
        const data = ENEMIES_DATA[Math.min(enemyIndex, ENEMIES_DATA.length - 1)];
        const scale = 1 + (Math.max(0, enemyIndex - (ENEMIES_DATA.length - 1)) * 0.5);
        
        enemy = {
            name: data.name,
            icon: data.icon,
            maxHp: Math.floor(data.hp * scale),
            hp: Math.floor(data.hp * scale),
            atk: Math.floor(data.atk * scale),
            exp: Math.floor(data.exp * scale),
            timer: 0
        };
        
        updateEnemyUI();
        log(`${enemy.name} „ÅåÁèæ„Çå„ÅüÔºÅ`);
        
        const visual = document.getElementById('enemy-visual');
        if (visual) {
            visual.innerText = enemy.icon;
            visual.classList.remove('shake-anim');
            void visual.offsetWidth; 
            visual.classList.add('shake-anim');
        }

        const enemyNameHudEl = document.getElementById('enemy-name-hud');
        if (enemyNameHudEl) enemyNameHudEl.innerHTML = `<span style="font-size: 1.2rem;">${enemy.icon}</span> ${enemy.name}`;
    }

    function update(time = 0) {
        if (!gameRunning) return;

        const deltaTime = time - lastTime;
        lastTime = time;

        dropCounter += deltaTime;
        if (dropCounter > dropInterval) {
            movePiece(0, 1);
            dropCounter = 0;
        }

        if (enemy) {
            enemy.timer += deltaTime;
            const pct = Math.min(100, (enemy.timer / ENEMY_ATTACK_INTERVAL) * 100);
            
            const timerDesktop = document.getElementById('enemy-timer-bar');
            const timerMobile = document.getElementById('enemy-timer-bar-hud');
            if (timerDesktop) timerDesktop.style.width = `${pct}%`;
            if (timerMobile) timerMobile.style.width = `${pct}%`;

            if (enemy.timer >= ENEMY_ATTACK_INTERVAL) {
                enemyAttack();
                enemy.timer = 0;
            }
        }

        draw();
        requestAnimationFrame(update);
    }
    
    function spawnPiece() {
        const typeIdx = nextPieceType !== null ? nextPieceType : (Math.random() * 7 | 0) + 1;
        nextPieceType = (Math.random() * 7 | 0) + 1;
        
        const pieceData = PIECES[typeIdx];
        
        currentPiece = {
            matrix: pieceData.shape,
            class: pieceData.class,
            x: (COLS / 2 | 0) - (pieceData.shape[0].length / 2 | 0),
            y: 0
        };

        const nextEl = document.getElementById('next-piece-display');
        if(nextEl) {
            nextEl.innerHTML = '';
            const nextData = PIECES[nextPieceType];
            if(nextData && nextData.shape) {
                nextEl.style.gridTemplateColumns = `repeat(${nextData.shape[0].length}, 1fr)`;
                nextEl.style.gridTemplateRows = `repeat(${nextData.shape.length}, 1fr)`;
                nextData.shape.forEach(row => {
                    row.forEach(val => {
                        const d = document.createElement('div');
                        if (val) {
                            d.className = nextData.class;
                            d.style.width='100%'; d.style.height='100%';
                        }
                        nextEl.appendChild(d);
                    });
                });
            }
        }

        if (collide(board, currentPiece)) {
            gameOver();
        }
    }

    function movePiece(dx, dy) {
        currentPiece.x += dx;
        currentPiece.y += dy;
        if (collide(board, currentPiece)) {
            currentPiece.x -= dx;
            currentPiece.y -= dy;
            if (dy > 0) {
                AudioSys.play('drop');
                merge(board, currentPiece);
                checkLines();
                spawnPiece();
            }
            return false;
        }
        if (dy === 0) AudioSys.play('move');
        return true;
    }

    function rotate(event) {
        if(event) event.preventDefault();
        const pos = currentPiece.x;
        let offset = 1;
        const matrix = currentPiece.matrix;
        
        const newMatrix = matrix[0].map((val, index) => matrix.map(row => row[index]).reverse());
        
        const oldMatrix = currentPiece.matrix;
        currentPiece.matrix = newMatrix;
        
        while (collide(board, currentPiece)) {
            currentPiece.x += offset;
            offset = -(offset + (offset > 0 ? 1 : -1));
            if (offset > newMatrix[0].length) {
                currentPiece.matrix = oldMatrix;
                currentPiece.x = pos;
                return;
            }
        }
        AudioSys.play('rotate');
    }

    function collide(scene, piece) {
        const m = piece.matrix;
        const o = {x: piece.x, y: piece.y};
        for (let y = 0; y < m.length; ++y) {
            for (let x = 0; x < m[y].length; ++x) {
                if (m[y][x] !== 0 &&
                (scene[y + o.y] && scene[y + o.y][x + o.x]) !== 0) {
                    return true;
                }
            }
        }
        return false;
    }

    function merge(scene, piece) {
        piece.matrix.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) {
                    const classIdx = PIECES.findIndex(p => p.class === piece.class);
                    scene[y + piece.y][x + piece.x] = classIdx; 
                }
            });
        });
        addMp(2);
    }

    function checkLines() {
        let linesCleared = 0;
        outer: for (let y = ROWS - 1; y > 0; --y) {
            for (let x = 0; x < COLS; ++x) {
                if (board[y][x] === 0) {
                    continue outer;
                }
            }
            const row = board.splice(y, 1)[0].fill(0);
            board.unshift(row);
            ++y;
            linesCleared++;
        }

        if (linesCleared > 0) {
            if(linesCleared >= 4) AudioSys.play('tetris');
            else AudioSys.play('clear');
            playerAttack(linesCleared);
        }
    }

    function draw() {
        const isMobile = window.innerWidth <= 768;
        
        for (let y = 0; y < ROWS; y++) {
            for (let c = 0; c < COLS; c++) {
                const cell = document.getElementById(`cell-${y}-${c}`);
                const val = board[y][c];
                
                cell.className = 'cell'; 

                if (isMobile) {
                    cell.style.top = `${y * 5}%`;
                    cell.style.left = `${c * 10}%`;
                } else {
                    cell.style.top = ''; 
                    cell.style.left = '';
                }

                if (val !== 0) {
                    cell.classList.add(PIECES[val].class);
                }
            }
        }

        if (currentPiece) {
            let ghostY = currentPiece.y;
            while(!collide(board, {matrix: currentPiece.matrix, x: currentPiece.x, y: ghostY + 1})) {
                ghostY++;
            }
            if(ghostY !== currentPiece.y) {
                currentPiece.matrix.forEach((row, y) => {
                    row.forEach((val, x) => {
                        if (val !== 0) {
                            const py = y + ghostY;
                            const px = x + currentPiece.x;
                            if (py >= 0 && py < ROWS && px >= 0 && px < COLS) {
                                const cell = document.getElementById(`cell-${py}-${px}`);
                                if(!cell.classList.contains(currentPiece.class)) {
                                    cell.classList.add('block-ghost');
                                }
                            }
                        }
                    });
                });
            }
            
            currentPiece.matrix.forEach((row, y) => {
                row.forEach((val, x) => {
                    if (val !== 0) {
                        const py = y + currentPiece.y;
                        const px = x + currentPiece.x;
                        if (py >= 0 && py < ROWS && px >= 0 && px < COLS) {
                            const cell = document.getElementById(`cell-${py}-${px}`);
                            cell.classList.remove('block-ghost'); 
                            cell.classList.add(currentPiece.class);
                        }
                    }
                });
            });
        }
    }

    function updatePlayerUI() {
        // Player Name Update
        const playerName = player.playerName || 'ÂêçÁÑ°„Åó';
        const playerNameDesktopEl = document.getElementById('player-name-desktop');
        const playerNameMobileHudEl = document.getElementById('player-name-mobile-hud');

        if (playerNameDesktopEl) playerNameDesktopEl.innerText = playerName;
        if (playerNameMobileHudEl) playerNameMobileHudEl.innerText = playerName;


        const hpPct = (player.hp / player.maxHp) * 100;
        const mpPct = (player.mp / player.maxMp) * 100;

        // Desktop
        const levelDesktop = document.getElementById('player-level');
        const atkDesktop = document.getElementById('player-atk');
        const hpBarDesktop = document.getElementById('hp-bar');
        const hpTextDesktop = document.getElementById('hp-text');
        const mpBarDesktop = document.getElementById('mp-bar');
        const mpTextDesktop = document.getElementById('mp-text');
        const expBar = document.getElementById('exp-bar');
        
        if (levelDesktop) levelDesktop.innerText = player.level;
        if (atkDesktop) atkDesktop.innerText = player.atk;
        if (hpBarDesktop) hpBarDesktop.style.width = `${hpPct}%`;
        if (hpTextDesktop) hpTextDesktop.innerText = `${player.hp}/${player.maxHp}`;
        if (mpBarDesktop) mpBarDesktop.style.width = `${mpPct}%`;
        if (mpTextDesktop) mpTextDesktop.innerText = `${player.mp}/${player.maxMp}`;
        if (expBar) expBar.style.width = `${(player.exp / player.expToNext) * 100}%`;


        // Mobile
        const hpBarMobile = document.getElementById('hp-bar-hud');
        const mpBarMobile = document.getElementById('mp-bar-hud');
        const playerLevelMobileEl = document.getElementById('player-level-mobile');
        
        if (hpBarMobile) hpBarMobile.style.width = `${hpPct}%`;
        if (mpBarMobile) mpBarMobile.style.width = `${mpPct}%`;
        if (playerLevelMobileEl) playerLevelMobileEl.innerText = player.level;

        // Buttons
        const healDisabled = player.mp < 20;
        const bombDisabled = player.mp < 30;
        
        const btnHealDesktop = document.getElementById('btn-heal');
        const btnBombDesktop = document.getElementById('btn-bomb');
        if (btnHealDesktop) btnHealDesktop.disabled = healDisabled;
        if (btnBombDesktop) btnBombDesktop.disabled = bombDisabled;
        
        const mobileHealBtn = document.querySelector('.mobile-controls-fixed button:nth-child(1)');
        const mobileBombBtn = document.querySelector('.mobile-controls-fixed button:nth-child(2)');
        if (mobileHealBtn) mobileHealBtn.disabled = healDisabled;
        if (mobileBombBtn) mobileBombBtn.disabled = bombDisabled;
    }

    function updateEnemyUI() {
        if(!enemy) return;
        
        const hpPct = Math.max(0, (enemy.hp / enemy.maxHp) * 100);

        // Desktop UI
        const enemyNameDesktop = document.getElementById('enemy-name');
        const enemyHPBarDesktop = document.getElementById('enemy-hp-bar');
        const enemyHPTextDesktop = document.getElementById('enemy-hp-text');

        if (enemyNameDesktop) enemyNameDesktop.innerText = enemy.name;
        if (enemyHPBarDesktop) enemyHPBarDesktop.style.width = `${hpPct}%`;
        if (enemyHPTextDesktop) enemyHPTextDesktop.innerText = enemy.hp;

        // Mobile HUD
        const enemyNameHudEl = document.getElementById('enemy-name-hud');
        if (enemyNameHudEl) enemyNameHudEl.innerHTML = `<span style="font-size: 1.2rem;">${enemy.icon}</span> ${enemy.name}`;
        document.getElementById('enemy-hp-bar-hud').style.width = `${hpPct}%`;
    }

    function playerAttack(lines) {
        const multiplier = lines === 4 ? 2.5 : lines === 3 ? 1.8 : lines === 2 ? 1.3 : 1.0;
        let damage = Math.ceil(player.atk * lines * multiplier);
        
        if(Math.random() < player.level * 0.02) {
            damage *= 2;
            log("CRITICAL HIT!!", "text-yellow-400");
            AudioSys.play('attack');
        } else {
            AudioSys.play('attack');
        }

        enemy.hp -= damage;
        
        const visualDesktop = document.getElementById('enemy-visual');
        const visualMobile = document.getElementById('enemy-name-hud');

        if (visualDesktop && visualDesktop.offsetParent !== null) showFloatingText(damage, '#enemy-visual', 'damage-text');
        else if (visualMobile && visualMobile.offsetParent !== null) showFloatingText(damage, '#enemy-name-hud', 'damage-text');
        
        log(`„É©„Ç§„É≥Ê∂àÂéª(${lines})! ${enemy.name}„Å´ ${damage} „ÉÄ„É°„Éº„Ç∏ÔºÅ`);
        
        const vis = document.getElementById('enemy-visual');
        if (vis) {
            vis.classList.remove('shake-anim');
            void vis.offsetWidth;
            vis.classList.add('shake-anim');
        }

        if (enemy.hp <= 0) {
            winBattle();
        } else {
            updateEnemyUI();
        }
    }

    function enemyAttack() {
        const variance = (Math.random() * 0.4) + 0.8;
        const damage = Math.ceil(enemy.atk * variance);
        
        player.hp -= damage;
        updatePlayerUI();
        log(`${enemy.name}„ÅÆÊîªÊíÉÔºÅ ${damage} „ÉÄ„É°„Éº„Ç∏„ÇíÂèó„Åë„ÅüÔºÅ`, "text-red-300");
        AudioSys.play('damage');
        
        document.body.classList.add('shake-anim');
        setTimeout(() => document.body.classList.remove('shake-anim'), 500);

        if (player.hp <= 0) {
            gameOver();
        }
    }

    function winBattle() {
        log(`${enemy.name} „ÇíÂÄí„Åó„ÅüÔºÅ`, "text-yellow-300");
        
        player.exp += enemy.exp;
        if (player.exp >= player.expToNext) {
            levelUp();
        }
        
        const heal = Math.floor(player.maxHp * 0.3);
        player.hp = Math.min(player.maxHp, player.hp + heal);
        log(`ÂãùÂà©„ÅÆ‰ºëÊÅØ„ÄÇHP„Åå ${heal} ÂõûÂæ©„Åó„Åü„ÄÇ`);
        
        enemyIndex++;
        enemy = null;
        updatePlayerUI();
        updateEnemyUI();

        setTimeout(() => {
            spawnEnemy();
        }, 1500);
    }

    function levelUp() {
        player.level++;
        player.exp -= player.expToNext;
        player.expToNext = Math.floor(player.expToNext * 1.5);
        
        player.maxHp += 20;
        player.hp = player.maxHp;
        player.maxMp += 10;
        player.mp = player.maxMp;
        player.atk += 3;
        
        log(`LEVEL UP! (Lv.${player.level}) Stats Increased!`, "text-green-400 font-bold");
        AudioSys.play('levelup');
    }

    function castSkill(skillName) {
        if (!gameRunning) return;

        if (skillName === 'heal') {
            if (player.mp >= 20) {
                player.mp -= 20;
                const amount = Math.floor(player.maxHp * 0.5);
                player.hp = Math.min(player.maxHp, player.hp + amount);
                log(`„Éí„Éº„É´ÔºÅ HP„Åå ${amount} ÂõûÂæ©„Åó„Åü„ÄÇ`, "text-green-300");
                showFloatingText(amount, '#tetris-board', 'heal-text');
                AudioSys.play('heal');
            }
        } else if (skillName === 'bomb') {
            if (player.mp >= 30) {
                player.mp -= 30;
                let cleared = 0;
                for(let y=ROWS-1; y>=10; y--) {
                    for(let x=0; x<COLS; x++) {
                        if(board[y][x] !== 0 && Math.random() < 0.5) {
                            board[y][x] = 0;
                            cleared++;
                        }
                    }
                }
                log(`„Éú„É†ÔºÅ ${cleared}ÂÄã„ÅÆ„Éñ„É≠„ÉÉ„ÇØ„ÇíÁ†¥Â£ä„Åó„ÅüÔºÅ`, "text-orange-400");
                AudioSys.play('damage');
                if(enemy) {
                    const bombDmg = player.atk * 3;
                    enemy.hp -= bombDmg;
                    
                    const visualDesktop = document.getElementById('enemy-visual');
                    const visualMobile = document.getElementById('enemy-name-hud');

                    if (visualDesktop && visualDesktop.offsetParent !== null) showFloatingText(bombDmg, '#enemy-visual', 'damage-text');
                    else if (visualMobile && visualMobile.offsetParent !== null) showFloatingText(bombDmg, '#enemy-name-hud', 'damage-text');
                    
                    if(enemy.hp <= 0) winBattle(); else updateEnemyUI();
                }
            }
        }
        updatePlayerUI();
    }

    function addMp(amount) {
        player.mp = Math.min(player.maxMp, player.mp + amount);
        updatePlayerUI();
    }
    
    function log(msg, colorClass = "text-white") {
        const el = document.createElement('div');
        el.className = `mb-1 ${colorClass}`;
        el.innerText = `> ${msg}`;
        
        if (logElDesktop) {
            const desktopEl = el.cloneNode(true);
            logElDesktop.appendChild(desktopEl);
            logElDesktop.scrollTop = logElDesktop.scrollHeight;
            if(logElDesktop.childElementCount > 100) logElDesktop.firstChild.remove();
        }
    }

    function showFloatingText(text, targetSelector, animClass) {
        const target = document.querySelector(targetSelector);
        if(!target) return;
        const rect = target.getBoundingClientRect();
        
        const el = document.createElement('div');
        el.innerText = text;
        el.className = animClass;
        el.style.left = (rect.left + rect.width/2) + 'px';
        el.style.top = (rect.top) + 'px';
        el.style.zIndex = 1000;
        
        document.body.appendChild(el);
        setTimeout(() => el.remove(), 1000);
    }

    // --- Input (PC Controls) ---
    document.addEventListener('keydown', event => {
        if (!gameRunning) return;
        
        if (event.keyCode === 37) { movePiece(-1, 0); } // Left
        else if (event.keyCode === 39) { movePiece(1, 0); } // Right
        else if (event.keyCode === 40) { movePiece(0, 1); addMp(0.5); } // Down
        else if (event.keyCode === 38) { rotate(); } // Up
        else if (event.keyCode === 32) { while(movePiece(0, 1)) {} } // Space (Drop)
        else if (event.key.toLowerCase() === 'z') { castSkill('heal'); }
        else if (event.key.toLowerCase() === 'x') { castSkill('bomb'); }
    });


    // --- Global Functions for HTML/Button Access ---
    window.startGame = startGame;
    window.castSkill = castSkill;
    window.toggleSound = toggleSound;
    window.showRanking = showRanking;
    window.hideRanking = hideRanking;

    
    // --- Initial App Load ---
    function initApp() {
        checkSaveData();
        document.getElementById('start-screen').classList.remove('hidden');
    }

    // --- Start App Init ---
    initApp();
</script>
</body>
</html>
